---
title: "Huynh 2020 Interim Analysis Code"
author: "Nikolai Klibansky"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  pdf_document:
    fig_caption: yes
    extra_dependencies:
      longtable: null
      xcolor: null
urlcolor: blue
---

```{r setup, include=FALSE, echo=FALSE}
rm(list=ls())
knitr::opts_chunk$set(comment=NA,echo=FALSE,message=FALSE,warning=FALSE,fig.height=8,fig.width=6)

library(Hmisc)
library(latex2exp) # lets you use TeX() function to convert latex equations to R expressions for plotting
library(stringr)
```

```{r functions}
# coefficient of variation
CV <- function(x,na.rm=TRUE){
  sd(x,na.rm=na.rm)/mean(x,na.rm=na.rm)
}

# geometric mean 
# Note that this will fail when x is a large value. exp(mean(log(x))) works better but can't handle negative values
GM <- function(x,na.rm=TRUE){
  if(na.rm){x <- as.numeric(na.omit(x))}
    prod(x)^(1/length(x))
    }
  

VB.L <- function(Linf,K,t0,a,ageProp=0)  {Linf*(1-exp(-K*(a+ageProp-t0))) }   # VB age to L

mat_L50_L95 <- function(L,L50,L95){
  r <- log((1-0.95)/0.95)/(L50-L95)
  P <- 1/(1+exp(-r*(L-L50)))
  return(P)
}

```

```{r data}
# Read in data for operating models (named "capelin_OM", etc.)
for(file.i in list.files("OM")){
  assign(gsub(".rds","",file.i),readRDS(file.path("OM",file.i)))
}

# Read in results (named "capelin_base_out", "capelin_dep_out", etc. )
for(file.i in list.files("MSE_obj")){
  assign(paste(gsub(".rds","",file.i),"out",sep="_"),readRDS(file.path("MSE_obj",file.i)))
}

```

```{r tables}
myOM <- vs_OM
OM_slotNames <- slotNames(myOM)
OM_slotData <- local({
  classes <- lengths <- dims <- preview <- rep(NA,length(OM_slotNames))
  for(slot_i in OM_slotNames){
    i <- which(OM_slotNames==slot_i)
    x_i <- slot(myOM,slot_i)
    
    class_i <- class(x_i)
    class_i <- paste(class_i,collapse=", ")
    classes[i] <- class_i
    
    lengths[i] <- length(x_i)
    dims[i]    <- ifelse(is.vector(x_i),NA,paste(dim(x_i),collapse = ", "))
    
    # if(is.vector(x_i)&!is.list(x_i)){print(paste(x_i[1:min(lengths[i],3)],collapse=", "))}
    
    preview[i] <- local({
      preview_i <- NA
      if(is.vector(x_i)&!is.list(x_i)){
        preview_i <- x_i[1:min(lengths[i],3)]
      }
      # if(is.matrix(x_i)&length(x_i>0)){
      #   preview_i <- x_i[1,1:min(ncol(x_i),3)]
      # }
      if(is.list(x_i)){
        preview_i <- names(x_i)[1:min(lengths[i],3)]
      }
      if(length(preview_i)<lengths[i]){
        preview_i <- paste(paste(preview_i,collapse=", "),", ...",collapse = "")
      }else{
        preview_i <- paste(preview_i,collapse=", ")
      }
      if(preview_i=="NA"){preview_i <- ""}
      preview_i  
    })
    
  }
  data.frame("slotName"=OM_slotNames,"class"=classes,"length"=lengths,"dim"=dims,"preview"=preview
             )
  
})

OM_slotData_latex <- local({
  OM_slotData_latex <- OM_slotData
  OM_slotData_latex$slotName <- gsub("_","\\_",OM_slotData$slotName,fixed=TRUE)
  OM_slotData_latex$preview <- gsub("_","\\_",OM_slotData$preview,fixed=TRUE)
  OM_slotData_latex
})

dummy <- latex(OM_slotData_latex,
               file="OM_slotData.tex",
               longtable = TRUE,
               rowname=NULL,
               caption="Slotnames of S4 operating model objects. Classes and lengths of slots and dimensions (dim) where appropriate are also provided.
               Previews of what is included in each slot vary by class: $\\leq 3$ values for vectors, $\\leq 3$  values in the first row for matrices, and $\\leq 3$ names for lists.")

```


## Purpose

This document explains what the Huynh et al (2020) code (\href{https://doi.org/10.5281/zenodo.3601687}{code link}) is doing and how it relates to the paper so that we can make sure we understand how their analysis works and replicate their results.

## Basic structure of the study and code files

The main code to run the analysis is in a file `run_script.R`. It intalls modified versions of the `DLMtool` and `MSEtool` packages from files included with the code (`DLMtool_5.3.1.tar.gz` and `MSEtool_1.4.1.tar.gz`). The main script `run_script.R` is actually pretty brief (105 lines) and relies heavily on the `DLMtool` and `MSEtool` packages. It seems like most of the novel coding that went into this project is in `iMP.R` in the `fn` folder. It's also not a very long script (267 lines) and mostly defines MPs and accessory functions.

The authors developed inputs for operating models (OM) based on three species:

1. Capelin (`capelin`)
2. Vermilion Snapper (`vs`)
3. Pacific Ocean Perch (`POP`)

The OM files are in the OM folder (\ttfamily `r list.files("OM")` \rmfamily)

The authors ran six scenarios for each OM:

1. Base (`base`)
2. Hyperstable (`hs`)
3. Hyperdeplete (`hd`)
4. Depleted (`dep`)
5. Lighly fished (`lf`)
6. Episodic M (`epiM`)

They ran 250 simulations for each species-scenario combination, and saved results in 18 files in the `MSE_obj` folder (e.g. \ttfamily `r list.files("MSE_obj")[c(1,2,13,14)]` \rmfamily). These resulting data files (.rds) provide results for 15 management procedures (MP), although only nine were used in the Huynh et al. (2020) paper. MPs that were not used are in gray text below.
Descriptions of the MPs below are from the `DLMTool` Help and comments in the `iMP.R` script:

1. \textcolor{gray}{\texttt{NFref}: A reference MP that sets annual catch to almost zero (0.01)}
2. \textcolor{gray}{\texttt{FMSYref75}: A reference FMSY method that fishes at 75\% of FMSY}
3. \textcolor{gray}{\texttt{FMSYref}: A reference FMSY method that fishes at FMSY}
4. \textcolor{gray}{\texttt{curE}: Set effort to 100\% of that in final year of historical simulations.}
5. \textcolor{gray}{\texttt{SQ}: ??? (I can't find any documentation for this MP)}
6. \textcolor{gray}{\texttt{AvC}: A simple average catch MP that is included to demonstrate a 'status quo' management option}
7. `SCA_1`: Statistical catch-at-age model run every 1 year (i.e. Annual assessment)
8. `SCA_5`: Statistical catch-at-age model run every 5 years (i.e. Fixed TAC (5))
9. `SCA_10`: Statistical catch-at-age model run every 10 years (i.e. Fixed TAC (10))
10. `iMP_5`: Averaged Index with assessments run every 5 years (i.e. `iMP_avg_5`)
11. `iMP_10`: Averaged Index with assessments run every 10 years (i.e. `iMP_avg_10`, Averaged Index (10))
12. `buffer_iMP_5`: Buffered Index MP, with assessments run every 5 years (i.e. Buffered Index (5)) 
13. `buffer_iMP_10`: Buffered Index MP, with assessments run every 10 years (i.e. Buffered Index (10))
14. `pMP_5`:  Projection MP with assessments run every 5 years (i.e. Projection (5))
15. `pMP_10`:  Projection MP with assessments run every 10 years (i.e. Projection (10))  

Unfortunately, the authors didn't include any plotting scripts or any other way to display the results with the code. The results files (e.g. `capelin_base_rds`) contain raw results 

## Connecting code to results from the paper

Length, maturity, and vulnerability (selectivity) at-age vectors associated with each operating model (species) are plotted in Figure \ref{fig:lifeHist}.

Time series of mean relative spawning biomass ($\mathrm{B^S/B_{MSY}^S}$) and mean relative yield ($\mathrm{C/MSY}$), of 250 simulations, are plotted in Figures \ref{fig:ssbssbmsyFourMP} and \ref{fig:cmsyFourMP} for four MPs [Annual assessment, Averaged Index (10), Buffered Index (10), and Fixed TAC (10)], for each species.

Dot-and-whisker plots of the coefficient of variation of time series of spawning stock biomass ($\mathrm{CV(B^S) = CVB}$) and geometric mean of relative yield ($\mathrm{geomean(C/MSY)=GMRY}$) for 250 simulations, are plotted in Figures \ref{fig:dotPlotCVB} and \ref{fig:dotPlotGMRY}, for nine MPs [Annual assessment, Averaged Index (10), Buffered Index (10), and Fixed TAC(10)], Averaged Index (5), Buffered Index (5), and Fixed TAC (5)]) for each species.

Time series of mean relative spawning biomass ($\mathrm{B^S/B_{MSY}^S}$) and mean relative yield ($\mathrm{C/MSY}$), of 250 simulations, are plotted in Figures \ref{fig:ssbssbmsyThreeMP} and \ref{fig:cmsyThreeMP}, for three MPs [Averaged Index (10), Buffered Index (10), and Projection (10)], for each species.

\clearpage

## Additional information
### OM files
The operating model files (e.g. `vs_OM.rds`) contain `r length(slotNames(vs_OM))` slots in a list-like S4 object, with the following slot names: `r paste(seq_along(slotNames(vs_OM)),slotNames(vs_OM),sep=". ")`.

### Results files
The results files (e.g. `vs_base.rds`) contain `r length(slotNames(vs_base_out))` slots in a list-like S4 object, with the following slot names: `r paste(seq_along(slotNames(vs_base_out)),slotNames(vs_base_out),sep=". ")`.

Some of these slots are more or less self explanatory. Many (all?) of them are explained in documentation for `DLMtool` (\href{https://cran.r-project.org/web/packages/DLMtool/DLMtool.pdf}{DLMtool.pdf link}) `MSEtool` (\href{https://cran.r-project.org/web/packages/MSEtool/MSEtool.pdf}{MSEtool.pdf link}).
However, you have to search the documents for the slot names to find what you're looking for, and it's a bit of a chore figuring out what's in the output.

```{r plot data, fig.cap="\\label{fig:lifeHist} Life history (growth and maturity) and vulnerability schedules at age used in the operating models for Capelin, Vermilion Snapper and POP. Growth is expressed as mean length-at-age relative to that at the maximum age. Compare with Huynh et al (2020) Figure 1."}
# Figure 1 from Huynh et al (2020)

plot_LH <- function(OM,...){
maxage <- OM@maxage
agebins <- 1:maxage
lenbins <- VB.L(Linf=OM@Linf[1],K=OM@K[1],t0=OM@t0[1],a=agebins)
Plenbins <- lenbins/max(lenbins)
Mat_age <- OM@cpars$Mat_age[1,,1] # Maturity at age
V <- OM@cpars$V[1,,1] # Vulnerability (selectivity) at age

plot(agebins,Plenbins,ylim=c(0,1),type="l",lwd=3,...)
points(agebins,Mat_age,type="l",lwd=3,lty=2)
points(agebins,V,type="l",lwd=3,lty=3)
}

par(mfrow=c(3,1),mgp=c(1,0.2,0),mar=c(1.5,2,1.5,1),oma=c(1,2,1,1),tck=-0.01)
plot_LH(capelin_OM,xlab="",ylab="",main="Capelin")
legend("bottomright",legend=c("Rel. length","Maturity","Vulnerability"),lwd=c(3,3,3),lty=c(1,2,3),bty="n")
plot_LH(vs_OM,xlab="",ylab="",main="Vermilion Snapper")
plot_LH(POP_OM,xlab="",ylab="",main="Pacific Ocean Perch")
mtext("Value",2,0,outer = TRUE)

```

```{r plot results setup}
OMNames <- c("capelin","vs","POP")
scenNames <- c("base","hs","hd","dep","lf","epiM")
MPNamesSub <- c("SCA_10","SCA_1","iMP_avg_10","iMP_buffer_10")
MPNamesSub_legtext <- c("Fixed\nTAC (10)", "Annual\nassessment","Averaged\nIndex (10)", "Buffered\nIndex (10)")
MSEoutNames <- paste(rep(OMNames,each=length(scenNames)),
                     rep(scenNames,length(OMNames)),
                     "out",
                     sep="_")
colLabs <- c("Capelin","Vermilion Snapper","Pacific Ocean Perch")
rowLabs <- c("Base","Hyper-stable","Hyper-deplete","Depleted","Lightly fished","Episodic M")

xlim <- c(0,50)
cols <- setNames(c("red","black","deepskyblue2","deepskyblue2"),MPNamesSub)
ltys <- setNames(c(1,1,1,2),MPNamesSub)
lwds <- setNames(c(3,3,3,3),MPNamesSub)
types <- setNames(c("l","l","l","l"),MPNamesSub)
colLabsAll <- as.character(matrix(c(colLabs,rep("",length(MSEoutNames)-length(colLabs))),ncol=length(colLabs),byrow=TRUE))
rowLabsAll <- as.character(matrix(c(rep("",length(MSEoutNames)-length(rowLabs)),rowLabs),nrow=length(rowLabs),byrow=FALSE))
```

```{r plot Figure 2, fig.cap="\\label{fig:ssbssbmsyFourMP} Annual mean $\\mathrm{B^S/B_{MSY}^S}$ from 250 simulations for each species (columns) and scenario (rows). Coloured lines correspond to the four MPs. Note that $\\mathrm{B^S=SSB}$. Compare with Huynh et al (2020) Figure 2."}
# Figure 2: Mean BS/BSmsy
myvarName <- "SSB"
ylabel <- expression(Mean~~B^S/B[MSY]^S)
ylim <- c(0,2)
assessmentYears <- seq(10,40,by=10)
x.at <- c(0,25,50)
y.at <- c(0,1,2)

layout(matrix(c(1:6,19,7:12,19,13:18,19), ncol=3, byrow=FALSE), heights=c(rep(1,6),0.75))
par(mgp=c(1,0.2,0),mar=c(0,0,0,0),oma=c(1,4,3,3),tck=-0.01,xpd=TRUE,xaxs="i",yaxs="i")

for(outName_i in MSEoutNames){
topPanels <- (length(scenNames)*(seq_along(OMNames)-1)+1)
bottomPanels <- length(scenNames)*seq_along(OMNames)
leftPanels <- seq_along(scenNames)
rightPanels <- tail(seq_along(MSEoutNames),length(scenNames))
  
i <- which(MSEoutNames==outName_i)
out_i <- get(outName_i)
MPNames <- out_i@MPs
myvar <- slot(out_i,myvarName)
SSBMSY <- slot(out_i,"OM")$SSBMSY

myvar <- myvar/SSBMSY # Scale myvar (catch by SSBMSY)

myvarsub <- myvar[,match(MPNamesSub,MPNames),]
myvarsubMeans <- apply(myvarsub,2,function(x){apply(x,2,mean)})
dimnames(myvarsubMeans) <- list(1:nrow(myvarsubMeans),MPNamesSub)

xaxt_i <- ifelse(i%in%bottomPanels,"n","n")
yaxt_i <- ifelse(i%in%leftPanels,"n","n")

matplot(rownames(myvarsubMeans),myvarsubMeans,
        col=cols,lty=ltys,lwd=lwds,type=types,
        xaxt=xaxt_i,yaxt=yaxt_i,
        xlim=xlim,ylim=ylim,xlab="",ylab="")
title(main=colLabsAll[i],line=1)
# grid(col="black")
points(par("usr")[1:2],c(1,1),type="l",lty="1111",lwd=1)
abline(v=assessmentYears,lty="1111",lwd=1)
if(i%in%topPanels){
col.ct <- which(topPanels==i)
mtext(colLabsAll[i],side=3,line=1,outer=TRUE,adj=c(0.15,0.5,0.97)[col.ct],font=2)
}
if(i%in%bottomPanels){
x.at.i <- x.at
if(i>bottomPanels[1]){x.at.i <- x.at[-1]}
axis(side=1,at=x.at.i)
}
if(i%in%leftPanels){
y.at.i <- y.at
if(i>leftPanels[1]){y.at.i <- y.at[1:(length(y.at)-1)]}
axis(side=2,at=y.at.i)
}
if(i%in%rightPanels){
row.ct <- which(rightPanels==i)
rowcenter <-par("usr")[3]+diff(par("usr")[3:4])/2

text(x=par("usr")[2]*1.05,y=rowcenter,rowLabsAll[i],
     srt=-90,xpd=NA,font=2)
}
}

mtext(ylabel,side=2,line=1.5,outer=TRUE)
mtext("Management year",side=1,line=1.5,outer=FALSE,adj=-4)
plot.new()
o <- c(2,3,4,1) # Order to plot legend elements
legend("bottom",horiz=TRUE,bty="n",
       legend=MPNamesSub_legtext[o],
       col=cols[o],lty=ltys[o],lwd=lwds[o]
       )
```

```{r plot Figure 3, fig.cap="\\label{fig:cmsyFourMP} Annual mean relative yield from 250 simulations for each species (columns) and scenario (rows). Coloured lines correspond to the four MPs. Compare with Huynh et al (2020) Figure 3."}
# Figure 3: Mean relative yield
myvarName <- "C"
ylabel <- "Mean relative yield"
ylim <- c(0,2)
assessmentYears <- seq(10,40,by=10)
x.at <- c(0,25,50)
y.at <- c(0,1,2)

layout(matrix(c(1:6,19,7:12,19,13:18,19), ncol=3, byrow=FALSE), heights=c(rep(1,6),0.75))
par(mgp=c(1,0.2,0),mar=c(0,0,0,0),oma=c(1,4,3,3),tck=-0.025,xpd=TRUE,xaxs="i",yaxs="i")

for(outName_i in MSEoutNames){
topPanels <- (length(scenNames)*(seq_along(OMNames)-1)+1)
bottomPanels <- length(scenNames)*seq_along(OMNames)
leftPanels <- seq_along(scenNames)
rightPanels <- tail(seq_along(MSEoutNames),length(scenNames))
  
i <- which(MSEoutNames==outName_i)
out_i <- get(outName_i)
MPNames <- out_i@MPs
myvar <- slot(out_i,myvarName)
MSY <- slot(out_i,"OM")$MSY

myvar <- myvar/MSY # Scale myvar (catch by MSY)

myvarsub <- myvar[,match(MPNamesSub,MPNames),]

myvarsubMeans <- apply(myvarsub,2,function(x){apply(x,2,mean)})
dimnames(myvarsubMeans) <- list(1:nrow(myvarsubMeans),MPNamesSub)

xaxt_i <- ifelse(i%in%bottomPanels,"n","n")
yaxt_i <- ifelse(i%in%leftPanels,"n","n")

matplot(rownames(myvarsubMeans),myvarsubMeans,
        col=cols,lty=ltys,lwd=lwds,type=types,
        xaxt=xaxt_i,yaxt=yaxt_i,
        xlim=xlim,ylim=ylim,xlab="",ylab="")
title(main=colLabsAll[i],line=1)
# grid(col="black")
points(par("usr")[1:2],c(1,1),type="l",lty="1111",lwd=1)
abline(v=assessmentYears,lty="1111",lwd=1)
if(i%in%topPanels){
col.ct <- which(topPanels==i)
mtext(colLabsAll[i],side=3,line=1,outer=TRUE,adj=c(0.15,0.5,0.97)[col.ct],font=2)
}
if(i%in%bottomPanels){
x.at.i <- x.at
if(i>bottomPanels[1]){x.at.i <- x.at[-1]}
axis(side=1,at=x.at.i)
}
if(i%in%leftPanels){
y.at.i <- y.at
if(i>leftPanels[1]){y.at.i <- y.at[1:(length(y.at)-1)]}
axis(side=2,at=y.at.i)
}
if(i%in%rightPanels){
row.ct <- which(rightPanels==i)
rowcenter <-par("usr")[3]+diff(par("usr")[3:4])/2
text(x=par("usr")[2]*1.05,y=rowcenter,rowLabsAll[i],
     srt=-90,xpd=NA,font=2)
}

}

mtext(ylabel,side=2,line=1.5,outer=TRUE)
mtext("Management year",side=1,line=1.5,outer=FALSE,adj=-4)
plot.new()
o <- c(2,3,4,1) # Order to plot legend elements
legend("bottom",horiz=TRUE,bty="n",
       legend=MPNamesSub_legtext[o],
       col=cols[o],lty=ltys[o],lwd=lwds[o]
       )
```

```{r plot Figure 4, fig.cap="\\label{fig:dotPlotCVB} Dot-and-whisker plots of CVB (coefficient of variation in spawning stock biomass) for each species (columns) and scenario (rows). For each MP, dots and numbers indicate the median from 250 simulations, and whiskers span the interquartile range. Compare with Huynh et al (2020) Figure 4."}
OMNames <- c("capelin","vs","POP")
scenNames <- c("base","hs","hd","dep","lf","epiM")
MPNamesSub <- c("SCA_1","iMP_avg_10","iMP_buffer_10","SCA_10", "pMP_10",
                        "iMP_avg_5", "iMP_buffer_5", "SCA_5",  "pMP_5")
MPNamesSub_legtext <- c("Annual assessment","Averaged Index (10)", "Buffered Index (10)","Fixed TAC (10)", "Projection (10)",
                                            "Averaged Index (5)",  "Buffered Index (5)", "Fixed TAC (5)",  "Projection (5)")
MSEoutNames <- paste(rep(OMNames,each=length(scenNames)),
                     rep(scenNames,length(OMNames)),
                     "out",
                     sep="_")
colLabs <- c("Capelin","Vermilion Snapper","Pacific Ocean Perch")
rowLabs <- c("Base","Hyper-stable","Hyper-deplete","Depleted","Lightly fished","Episodic M")

xlim <- c(0,length(MPNamesSub)+1)
ylim <- c(-.2,1)
cols <- setNames(c("black",rep(rep(c("deepskyblue2","red"),each=2),2)),MPNamesSub)
ltys <- setNames(c(1,rep(c(1,2),4)),MPNamesSub)
lwds <- setNames(rep(1,length(MPNamesSub)),MPNamesSub)
pchs <-  setNames(c(16,rep(c(16,21),4)),MPNamesSub)
types <- setNames(rep("p",length(MPNamesSub)),MPNamesSub)
colLabsAll <- as.character(matrix(c(colLabs,rep("",length(MSEoutNames)-length(colLabs))),ncol=length(colLabs),byrow=TRUE))
rowLabsAll <- as.character(matrix(c(rep("",length(MSEoutNames)-length(rowLabs)),rowLabs),nrow=length(rowLabs),byrow=FALSE))

myvarName <- "SSB"
ylabel <- "CVB (actually it's the CV of SSB)"
ylim <- c(0,1.25)
y.at <- c(0,0.5,1)
textlabpos <- c(rep("lo",6),rep("up",7),"lo",rep("up",4))

layout(matrix(c(1:6,19,7:12,19,13:18,19), ncol=3, byrow=FALSE), heights=c(rep(1,6),0.75))
par(mgp=c(1,0.2,0),mar=c(0,0,0,0),oma=c(4,3,3,3),tck=-0.01,xpd=TRUE,xaxs="i",yaxs="r",lend="butt")

for(outName_i in MSEoutNames){
topPanels <- (length(scenNames)*(seq_along(OMNames)-1)+1)
bottomPanels <- length(scenNames)*seq_along(OMNames)
leftPanels <- seq_along(scenNames)
rightPanels <- tail(seq_along(MSEoutNames),length(scenNames))
  
i <- which(MSEoutNames==outName_i)
out_i <- get(outName_i)
MPNames <- out_i@MPs
myvar <- slot(out_i,myvarName)

myvarsub <- myvar[,match(MPNamesSub,MPNames),]
myvarsubCVs <- apply(myvarsub,2,function(x){apply(x,1,CV)})
dimnames(myvarsubCVs) <- list(1:nrow(myvarsubCVs),MPNamesSub)

CVBmed <- apply(myvarsubCVs,2,median)
CVBmedtext <- round(CVBmed,2)
CVBQ1 <- apply(myvarsubCVs,2,quantile,probs=0.25)
CVBQ3 <- apply(myvarsubCVs,2,quantile,probs=0.75)

xaxt_i <- ifelse(i%in%bottomPanels,"n","n")
yaxt_i <- ifelse(i%in%leftPanels,"n","n")
x <- seq_along(MPNamesSub)
plot(x,CVBmed,
        col=cols,pch=pchs,type="n",bg="white",
        xaxt=xaxt_i,yaxt=yaxt_i,
        xlim=xlim,ylim=ylim,xlab="",ylab="")
arrows(x0=x,y0=CVBQ1,y1=CVBQ3,
       col=cols,lty=ltys,lwd=lwds,length=0
       )
points(x,CVBmed,
        col=cols,pch=pchs,type="p",bg="white",cex=1.2,
        xaxt=xaxt_i,yaxt=yaxt_i,
        xlim=xlim,ylim=ylim,xlab="",ylab="")

if(textlabpos[i]=="lo"){text(x=x,y=rep(par("usr")[3]),labels=CVBmedtext,srt=90,adj=c(-0.1,0.5),font=2)}
if(textlabpos[i]=="up"){text(x=x,y=rep(par("usr")[4]),labels=CVBmedtext,srt=90,adj=c(1.2,0.5),font=2)}

title(main=colLabsAll[i],line=1)
abline(v=c(1.5,5.5),col="gray")
# grid(col="black")

if(i%in%topPanels){
col.ct <- which(topPanels==i)
mtext(colLabsAll[i],side=3,line=1,outer=TRUE,adj=c(0.15,0.5,0.97)[col.ct],font=2)
}
if(i%in%bottomPanels){
axis(side=1,at=x,labels=MPNamesSub_legtext,las=2)
}
if(i%in%leftPanels){
y.at.i <- y.at
# if(i>leftPanels[1]){y.at.i <- y.at[1:(length(y.at)-1)]}
axis(side=2,at=y.at.i)
}
if(i%in%rightPanels){
row.ct <- which(rightPanels==i)
rowcenter <-par("usr")[3]+diff(par("usr")[3:4])/2

text(x=par("usr")[2]*1.05,y=rowcenter,rowLabsAll[i],
     srt=-90,xpd=NA,font=2)
}

}

mtext(ylabel,side=2,line=1.5,outer=TRUE)
mtext("Management procedure",side=1,line=2.5,outer=TRUE)
```

```{r plot Figure 5, fig.cap="\\label{fig:dotPlotGMRY} Dot-and-whisker plots of GMRY (geometric mean of relative yield) for each species (columns) and scenario (rows). For each MP,dots and numbers indicate the median from 250 simulations, and whiskers span the interquartile range. Dotted, horizontal lines indicate a value of 1. Compare with Huynh et al (2020) Figure 4."}
OMNames <- c("capelin","vs","POP")
scenNames <- c("base","hs","hd","dep","lf","epiM")
MPNamesSub <- c("SCA_1","iMP_avg_10","iMP_buffer_10","SCA_10", "pMP_10",
                        "iMP_avg_5", "iMP_buffer_5", "SCA_5",  "pMP_5")
MPNamesSub_legtext <- c("Annual assessment","Averaged Index (10)", "Buffered Index (10)","Fixed TAC (10)", "Projection (10)",
                                            "Averaged Index (5)",  "Buffered Index (5)", "Fixed TAC (5)",  "Projection (5)")
MSEoutNames <- paste(rep(OMNames,each=length(scenNames)),
                     rep(scenNames,length(OMNames)),
                     "out",
                     sep="_")
colLabs <- c("Capelin","Vermilion Snapper","Pacific Ocean Perch")
rowLabs <- c("Base","Hyper-stable","Hyper-deplete","Depleted","Lightly fished","Episodic M")

xlim <- c(0.25,length(MPNamesSub)+0.75)
ylim <- c(0,1.25)
cols <- setNames(c("black",rep(rep(c("deepskyblue2","red"),each=2),2)),MPNamesSub)
ltys <- setNames(c(1,rep(c(1,2),4)),MPNamesSub)
lwds <- setNames(rep(1,length(MPNamesSub)),MPNamesSub)
pchs <-  setNames(c(16,rep(c(16,21),4)),MPNamesSub)
types <- setNames(rep("p",length(MPNamesSub)),MPNamesSub)
colLabsAll <- as.character(matrix(c(colLabs,rep("",length(MSEoutNames)-length(colLabs))),ncol=length(colLabs),byrow=TRUE))
rowLabsAll <- as.character(matrix(c(rep("",length(MSEoutNames)-length(rowLabs)),rowLabs),nrow=length(rowLabs),byrow=FALSE))

myvarName <- "C"
ylabel <- "GMRY"
y.at <- c(0.25,0.75)
textlabpos <- c(rep("lo",6),rep("up",7),"lo",rep("up",4))

layout(matrix(c(1:6,19,7:12,19,13:18,19), ncol=3, byrow=FALSE), heights=c(rep(1,6),0.75))
par(mgp=c(1,0.2,0),mar=c(0,0,0,0),oma=c(4,3,3,3),tck=-0.01,xpd=TRUE,xaxs="i",yaxs="r",lend="butt")

for(outName_i in MSEoutNames){
topPanels <- (length(scenNames)*(seq_along(OMNames)-1)+1)
bottomPanels <- length(scenNames)*seq_along(OMNames)
leftPanels <- seq_along(scenNames)
rightPanels <- tail(seq_along(MSEoutNames),length(scenNames))
  
i <- which(MSEoutNames==outName_i)
out_i <- get(outName_i)
MPNames <- out_i@MPs
myvar <- slot(out_i,myvarName)
MSY <- slot(out_i,"OM")$MSY

myvar <- myvar/MSY # Scale myvar (catch by MSY)

myvarsub <- myvar[,match(MPNamesSub,MPNames),]
myvarsubGMs <- apply(myvarsub,2,function(x){apply(x,1,GM)})
dimnames(myvarsubGMs) <- list(1:nrow(myvarsubGMs),MPNamesSub)

GMBmed <- apply(myvarsubGMs,2,median)
GMBmedtext <- round(GMBmed,2)
GMBQ1 <- apply(myvarsubGMs,2,quantile,probs=0.25)
GMBQ3 <- apply(myvarsubGMs,2,quantile,probs=0.75)

xaxt_i <- ifelse(i%in%bottomPanels,"n","n")
yaxt_i <- ifelse(i%in%leftPanels,"n","n")
x <- seq_along(MPNamesSub)
plot(x,GMBmed,
        col=cols,pch=pchs,type="n",bg="white",
        xaxt=xaxt_i,yaxt=yaxt_i,
        xlim=xlim,ylim=ylim,xlab="",ylab="")
arrows(x0=x,y0=GMBQ1,y1=GMBQ3,
       col=cols,lty=ltys,lwd=lwds,length=0
       )
points(x,GMBmed,
        col=cols,pch=pchs,type="p",bg="white",cex=1.2,
        xaxt=xaxt_i,yaxt=yaxt_i,
        xlim=xlim,ylim=ylim,xlab="",ylab="")
text(x=x,y=rep(par("usr")[3]),labels=GMBmedtext,srt=90,adj=c(-0.1,0.5),font=2)
title(main=colLabsAll[i],line=1)
abline(v=c(1.5,5.5),col="gray")
abline(h=1,lty=3)
# grid(col="black")

if(i%in%topPanels){
col.ct <- which(topPanels==i)
mtext(colLabsAll[i],side=3,line=1,outer=TRUE,adj=c(0.15,0.5,0.97)[col.ct],font=2)
}
if(i%in%bottomPanels){
axis(side=1,at=x,labels=MPNamesSub_legtext,las=2)
}
if(i%in%leftPanels){
y.at.i <- y.at
# if(i>leftPanels[1]){y.at.i <- y.at[1:(length(y.at)-1)]}
axis(side=2,at=y.at.i)
}
if(i%in%rightPanels){
row.ct <- which(rightPanels==i)
rowcenter <-par("usr")[3]+diff(par("usr")[3:4])/2

text(x=par("usr")[2]*1.05,y=rowcenter,rowLabsAll[i],
     srt=-90,xpd=NA,font=2)
}

}

mtext(ylabel,side=2,line=1.5,outer=TRUE) # Add y label
mtext("Management procedure",side=1,line=2.5,outer=TRUE)
```

```{r plot results setup2}
# OMNames <- unique(str_extract(list.files("MSE_obj"),"[a-zA-Z]+"))
MPNamesSub <- c("iMP_avg_10","iMP_buffer_10","pMP_10")
MPNamesSub_legtext <- c("Averaged\nIndex (10)", "Buffered\nIndex (10)","Projection (10)")
MSEoutNames <- paste(rep(OMNames,each=length(scenNames)),
                     rep(scenNames,length(OMNames)),
                     "out",
                     sep="_")
colLabs <- c("Capelin","Vermilion Snapper","Pacific Ocean Perch")
rowLabs <- c("Base","Hyper-stable","Hyper-deplete","Depleted","Lightly fished","Episodic M")

xlim <- c(0,50)
cols <- setNames(c("deepskyblue2","deepskyblue2","red"),MPNamesSub)
ltys <- setNames(c(1,2,2),MPNamesSub)
lwds <- setNames(c(3,3,3),MPNamesSub)
types <- setNames(c("l","l","l"),MPNamesSub)
colLabsAll <- as.character(matrix(c(colLabs,rep("",length(MSEoutNames)-length(colLabs))),ncol=length(colLabs),byrow=TRUE))
rowLabsAll <- as.character(matrix(c(rep("",length(MSEoutNames)-length(rowLabs)),rowLabs),nrow=length(rowLabs),byrow=FALSE))
```

```{r plot Figure 6, fig.cap="\\label{fig:ssbssbmsyThreeMP} Annual mean $\\mathrm{B^S/B_{MSY}^S}$ from 250 simulations for each species (columns) and scenario (rows) comparing the Averaged Index, Buffered Index and Projection MPs. Coloured lines correspond to the three MPs. Compare with Huynh et al (2020) Figure 6."}
# Figure 6: Mean SSB/SSBmsy
myvarName <- "SSB"
ylabel <- expression(Mean~~B^S/B[MSY]^S)
ylim <- c(0,2)
assessmentYears <- seq(10,40,by=10)
x.at <- c(0,25,50)
y.at <- c(0,1,2)

layout(matrix(c(1:6,19,7:12,19,13:18,19), ncol=3, byrow=FALSE), heights=c(rep(1,6),0.75))
par(mgp=c(1,0.2,0),mar=c(0,0,0,0),oma=c(1,4,3,3),tck=-0.025,xpd=TRUE,xaxs="i",yaxs="i")

for(outName_i in MSEoutNames){
topPanels <- (length(scenNames)*(seq_along(OMNames)-1)+1)
bottomPanels <- length(scenNames)*seq_along(OMNames)
leftPanels <- seq_along(scenNames)
rightPanels <- tail(seq_along(MSEoutNames),length(scenNames))
  
i <- which(MSEoutNames==outName_i)
out_i <- get(outName_i)
MPNames <- out_i@MPs
myvar <- slot(out_i,myvarName)
SSBMSY <- slot(out_i,"OM")$SSBMSY

myvar <- myvar/SSBMSY # Scale myvar (catch by SSBMSY)

myvarsub <- myvar[,match(MPNamesSub,MPNames),]
myvarsubMeans <- apply(myvarsub,2,function(x){apply(x,2,mean)})
dimnames(myvarsubMeans) <- list(1:nrow(myvarsubMeans),MPNamesSub)

xaxt_i <- ifelse(i%in%bottomPanels,"n","n")
yaxt_i <- ifelse(i%in%leftPanels,"n","n")

matplot(rownames(myvarsubMeans),myvarsubMeans,
        col=cols,lty=ltys,lwd=lwds,type=types,
        xaxt=xaxt_i,yaxt=yaxt_i,
        xlim=xlim,ylim=ylim,xlab="",ylab="")
title(main=colLabsAll[i],line=1)
# grid(col="black")
points(par("usr")[1:2],c(1,1),type="l",lty="1111",lwd=1)
abline(v=assessmentYears,lty="1111",lwd=1)
if(i%in%topPanels){
col.ct <- which(topPanels==i)
mtext(colLabsAll[i],side=3,line=1,outer=TRUE,adj=c(0.15,0.5,0.97)[col.ct],font=2)
}
if(i%in%bottomPanels){
x.at.i <- x.at
if(i>bottomPanels[1]){x.at.i <- x.at[-1]}
axis(side=1,at=x.at.i)
}
if(i%in%leftPanels){
y.at.i <- y.at
if(i>leftPanels[1]){y.at.i <- y.at[1:(length(y.at)-1)]}
axis(side=2,at=y.at.i)
}
if(i%in%rightPanels){
row.ct <- which(rightPanels==i)
rowcenter <-par("usr")[3]+diff(par("usr")[3:4])/2
text(x=par("usr")[2]*1.05,y=rowcenter,rowLabsAll[i],
     srt=-90,xpd=NA,font=2)
}

}

mtext(ylabel,side=2,line=1.5,outer=TRUE)
mtext("Management year",side=1,line=1.5,outer=FALSE,adj=-4)
plot.new()
o <- c(1,2,3) # Order to plot legend elements
legend("bottom",horiz=TRUE,bty="n",
       legend=MPNamesSub_legtext[o],
       col=cols[o],lty=ltys[o],lwd=lwds[o]
       )
```

```{r plot Figure 7, fig.cap="\\label{fig:cmsyThreeMP} Annual mean relative yield from 250 simulations for each species (columns) and scenario (rows) comparing the Averaged Index, Buffered Index and Projection MPs. Coloured lines correspond to the three MPs. Compare with Huynh et al (2020) Figure 7."}
# Figure 6: Mean relative yield
myvarName <- "C"
ylabel <- "Mean relative yield"
ylim <- c(0,2)
assessmentYears <- seq(10,40,by=10)
x.at <- c(0,25,50)
y.at <- c(0,1,2)

layout(matrix(c(1:6,19,7:12,19,13:18,19), ncol=3, byrow=FALSE), heights=c(rep(1,6),0.75))
par(mgp=c(1,0.2,0),mar=c(0,0,0,0),oma=c(1,4,3,3),tck=-0.025,xpd=TRUE,xaxs="i",yaxs="i")

for(outName_i in MSEoutNames){
topPanels <- (length(scenNames)*(seq_along(OMNames)-1)+1)
bottomPanels <- length(scenNames)*seq_along(OMNames)
leftPanels <- seq_along(scenNames)
rightPanels <- tail(seq_along(MSEoutNames),length(scenNames))
  
i <- which(MSEoutNames==outName_i)
out_i <- get(outName_i)
MPNames <- out_i@MPs
myvar <- slot(out_i,myvarName)
MSY <- slot(out_i,"OM")$MSY

myvar <- myvar/MSY # Scale myvar (catch by MSY)

myvarsub <- myvar[,match(MPNamesSub,MPNames),]
myvarsubMeans <- apply(myvarsub,2,function(x){apply(x,2,mean)})
dimnames(myvarsubMeans) <- list(1:nrow(myvarsubMeans),MPNamesSub)

xaxt_i <- ifelse(i%in%bottomPanels,"n","n")
yaxt_i <- ifelse(i%in%leftPanels,"n","n")

matplot(rownames(myvarsubMeans),myvarsubMeans,
        col=cols,lty=ltys,lwd=lwds,type=types,
        xaxt=xaxt_i,yaxt=yaxt_i,
        xlim=xlim,ylim=ylim,xlab="",ylab="")
title(main=colLabsAll[i],line=1)
# grid(col="black")
points(par("usr")[1:2],c(1,1),type="l",lty="1111",lwd=1)
abline(v=assessmentYears,lty="1111",lwd=1)
if(i%in%topPanels){
col.ct <- which(topPanels==i)
mtext(colLabsAll[i],side=3,line=1,outer=TRUE,adj=c(0.15,0.5,0.97)[col.ct],font=2)
}
if(i%in%bottomPanels){
x.at.i <- x.at
if(i>bottomPanels[1]){x.at.i <- x.at[-1]}
axis(side=1,at=x.at.i)
}
if(i%in%leftPanels){
y.at.i <- y.at
if(i>leftPanels[1]){y.at.i <- y.at[1:(length(y.at)-1)]}
axis(side=2,at=y.at.i)
}
if(i%in%rightPanels){
row.ct <- which(rightPanels==i)
rowcenter <-par("usr")[3]+diff(par("usr")[3:4])/2
text(x=par("usr")[2]*1.05,y=rowcenter,rowLabsAll[i],
     srt=-90,xpd=NA,font=2)
}

}

mtext(ylabel,side=2,line=1.5,outer=TRUE)
mtext("Management year",side=1,line=1.5,outer=FALSE,adj=-4)
plot.new()
o <- c(1,2,3) # Order to plot legend elements
legend("bottom",horiz=TRUE,bty="n",
       legend=MPNamesSub_legtext[o],
       col=cols[o],lty=ltys[o],lwd=lwds[o]
       )
```

\clearpage

### Appendix

\include{OM_slotData.tex}